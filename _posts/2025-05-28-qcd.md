---
layout: distill
title: "QCD: Quantization Contrastive Decoding"
description: QCD Quantization Contrasitve Decoding
tags: distill formatting
giscus_comments: true
date: 2025-05-28
featured: true
mermaid:
  enabled: true
  zoomable: true
code_diff: true
map: true
chart:
  chartjs: true
  echarts: true
  vega_lite: true
tikzjax: true
typograms: true

authors:
  - name: Byeongho YU (20242666)
    affiliations:
      name: POSTECH
  - name: Jungyu Jin
    affiliations:
      name: POSTECH
  - name: Sangyoon Oh
    affiliations:
      name: POSTECH

bibliography: 2018-12-22-distill.bib

# Optionally, you can add a table of contents to your post.
# NOTES:
#   - make sure that TOC names match the actual section names
#     for hyperlinks within the post to work correctly.
#   - we may want to automate TOC generation in the future using
#     jekyll-toc plugin (https://github.com/toshimaru/jekyll-toc).
toc:
  - name: Contrastive Decoding (CD) and the Role of the Amateur Model
    subsections:
      - name: 1. What is Contrastive Decoding (CD)?
      - name: 2. Dependence on a Smaller "Amateur" Model
    # if a section has subsections, you can add them as follows:
    # subsections:
    #   - name: Example Child Subsection 1
    #   - name: Example Child Subsection 2
  - name: Workarounds When No Amateur Model Is Available
  - name: Quantization of LLMs

# Below is an example of injecting additional post-specific styles.
# If you use this post as a template, delete this _styles block.
_styles: >
  .fake-img {
    background: #bbb;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 0px 4px rgba(0, 0, 0, 0.1);
    margin-bottom: 12px;
  }
  .fake-img p {
    font-family: monospace;
    color: white;
    text-align: left;
    margin: 12px 0;
    text-align: center;
    font-size: 16px;
  }
---

## Contrastive Decoding (CD) and the Role of the Amateur Model

### 1. What is Contrastive Decoding (CD)?
Contrastive Decoding (CD) is a novel decoding method proposed to improve the quality of text generation in large language models (LLMs). Traditional decoding strategies like greedy decoding select the highest-probability token at each step, which can result in highly degenerate behavior such as repetitive or overly concise text. On the other hand, probabilistic sampling (e.g., temperature sampling, top-k, or nucleus sampling) introduces randomness to improve diversity, but often at the cost of coherence and relevance. CD aims to combine the strengths of both while avoiding their weaknesses by leveraging two language models and optimizing a contrastive objective.

- Greedy decoding tends to produce repetitive and overly simple outputs by always selecting the highest-probability token.
- Sampling-based decoding introduces diversity by adding randomness but can result in incoherent or off-topic responses.
- Contrastive Decoding uses a large expert model and a smaller amateur model. It selects tokens that are favored by the expert model but not by the amateur model. This amplifies the expert's strengths while suppressing undesirable patterns learned by the weaker model.

The core idea behind CD is to exploit the difference in token likelihoods predicted by the two models. The score for a candidate token  is calculated as:

$$ \text{Score}(x) = \log P_{\text{expert}}(x \mid \text{context}) - \lambda \log P_{\text{amateur}}(x \mid \text{context}) $$

Here, $P_{\text{expert}}$ is the probability from the expert model, $P_{\text{amateur}}$ is from the amateur model, and  $\lambda$ is a balancing factor (often set to 1). This scoring mechanism favors tokens that are highly likely under the expert but unlikely under the amateur, indicating fluency and novelty.

To prevent pathological cases (e.g., selecting implausible or noisy tokens), a plausibility constraint is applied. That is, only tokens whose expert likelihood exceeds a certain threshold are considered:

$$ x \in \{ w \in \mathcal{V} \mid P_{\text{expert}}(w \mid \text{context}) \geq \alpha \cdot \max_{w'} P_{\text{expert}}(w' \mid \text{context}) \} $$

This ensures grammatical and contextual coherence.

CD can be viewed as a strategy to balance the expert's fluency with the amateur's bias toward generic or degenerate outputs. For instance, in a conversational context, greedy decoding might generate repetitive named entities ("Hawaii", "Honolulu"), and sampling might lead to irrelevant answers ("Washington"). CD can select a factually correct and coherent token ("1961") that reflects deeper reasoning.

Later studies also show that CD not only improves generation quality but enhances reasoning ability. For example, O'Brien & Lewis (2023) demonstrated that CD-enhanced LLaMA-65B outperformed larger models like GPT-3.5 and PaLM 2 on benchmarks such as HellaSwag and GSM8K. CD discourages superficial answers by penalizing shallow or obvious completions preferred by smaller models, encouraging deeper inference paths.

### 2. Dependence on a Smaller "Amateur" Model

CD critically depends on having a separate, weaker model from the same family. The idea is that most generation failures (e.g., repetition, genericity, off-topic responses) are more frequent in smaller models. By contrasting the expert with an amateur, CD uses this signal to avoid such failure modes.

If the same model is used for both expert and amateur, then:

$$ \log P_{\text{expert}}(x) - \lambda \log P_{\text{amateur}}(x) = (1 - \lambda) \log P(x) $$

With $ \lambda = 1 $ , all scores become zero, meaning no preference among tokens—rendering CD useless. Empirically, this results in degenerate outputs, often indistinguishable from greedy decoding.

In contrast, the larger the gap between expert and amateur models (e.g., 13B vs. 125M), the greater the divergence in token predictions, and hence stronger signals for CD. Experiments in the original paper show that using a substantially smaller model yields better results in terms of coherence and richness of the generated text.

However, the amateur model cannot be arbitrarily weak. If it's too underpowered (e.g., a basic n-gram model), its predictions become too noisy and uninformative. Instead, it should be a scaled-down version of the same model family, preserving the architecture and vocabulary.

Without such a smaller counterpart, CD becomes hard to apply. If you fine-tune a new LLM (e.g., a custom 7B model), and no aligned 125M version exists, CD may not be feasible. Researchers have noted this limitation—CD typically requires an available amateur model within the same family.

In summary:
- CD requires a meaningful contrast between two LMs.
- A separate, weaker amateur model provides a reliable penalty signal.
- Using the same model or an overly weak one undermines CD’s mechanism.

CD thus offers a decoding-time method to enhance both generation fluency and reasoning depth, without retraining the model, by leveraging how smaller models tend to fall into repetitive or shallow patterns. The expert model learns to avoid these patterns via contrastive scoring.

## Workarounds When No Amateur Model Is Available

In practice, we may not always have a smaller “amateur” model on hand for contrastive decoding. One notable approach is Induce-then-Contrast Decoding (ICD) (Yue Zhang et al, 2024), which turns the original LLM into both the expert and the amateur in a two-phase process . The idea is to induce the big model to produce hallucinations (thereby acting like a factually deficient model) and then contrast those hallucinated outputs against the normal model’s outputs. This effectively penalizes content that looks like the model’s known hallucinations, guiding the decoder towards more truthful results.

**How does the model hallucinate on purpose?** 

The authors of ICD construct a *factuality-weak* version of the LLM – essentially an “evil twin” that has a higher tendency to fabricate information. One of the methods the authors chose was to **create an “evil-twin” model by fine-tuning the original LLM on False Dataset**. For the strongest effect, one can fine-tune a copy of the model on a small, synthetic dataset of factual errors. In the ICD paper, the authors automatically generated non-factual Q&A examples (e.g. altering a correct fact “ACL 2024 will be held in Bangkok” into a false version “ACL 2024 will be held in Singapore”) and fine-tuned the LLM on these hallucination-style responses . This “hallucination-happy” model serves as a robust amateur that consistently produces fluent yet incorrect outputs. 

Once we have the original model and an induced-hallucination version with fine-tuning, we perform **contrastive decoding between them at each step**. This contrastive re-weighting steers the final choice away from content the model’s “weak alter-ego” would say, thereby filtering out potential fabrications without needing an external smaller network.

Crucially, this induced contrast method maintains the benefits of using a powerful LLM while creating an internal check against its own flaws. The results reported for ICD are impressive: across multiple benchmarks, **a single 7B model using ICD can match or even surpass the factuality of models that are 10× larger** .This highlights that a carefully induced “amateur” can be far more informative than a generic smaller model. The contrast signal is directly tuned to the kinds of mistakes the expert would otherwise make, so it catches factual errors that might slip past an unrelated weaker model.

**Limitations**

While this induce-and-contrast method can markedly improve factual accuracy, it carries **substantial overhead on two fronts**. First, inference now needs **two forward passes** instead of one, roughly doubling per-token compute (the authors report ≈1.6 × latency). **Second—and often more costly—you must actually create the hallucination-prone “evil-twin” model via a separate fine-tuning step.** Even with lightweight adapters such as LoRA, this demands extra GPU hours, synthetic data generation, additional checkpoints to store, and a parallel deployment path to maintain. In short, Induce-then-Contrast is a powerful stop-gap when no pre-trained amateur model exists—it lets you bake one from scratch—but it is **anything but a free lunch** in engineering effort, training time, and runtime cost.


## Quantization of LLMs

Before diving into main section of this blog post, let’s briefly recap model quantization. **Quantization** means compressing a neural network by using fewer bits to represent weights (and sometimes activations), thereby drastically reducing memory and speeding up inference . Modern LLMs often use 16-bit or 32-bit floats; quantization can shrink them to 8-bit or even 4-bit integers. The big question is: *how does quantization affect an LLM’s performance, especially on reasoning tasks?* Recent empirical studies have started to answer this. 

**Liu et al. (2025)** conducted a comprehensive study titled *“Quantization Hurts Reasoning? An Empirical Study on Quantized Reasoning Models.”* They found that moderate quantization can preserve accuracy, but **aggressive low-bit quantization does degrade reasoning performance** . In particular, using 8-bit weights (or a 4-bit weight with 16-bit activations, denoted W8A8 or W4A16) was nearly *lossless* on a variety of math, science, and coding benchmarks . However, pushing to 4-bit or 3-bit weights across the board introduced significant accuracy drops on these reasoning-heavy tasks . This suggests that **reasoning LLMs are somewhat fragile to quantization.**
